# Scribble Copilot Instructions

- **Overview**: Scribble is a Micropub server in Go 1.25 that exposes `GET /`, `POST /`, and `POST /media` endpoints; main entry is `cmd/scribble.go` and `server/server.go` wires routes and graceful shutdown.
- **Request auth**: Tokens are verified against the configured Micropub token endpoint via bearer header or body `access_token`; never allow both (see `middleware.EnsureTokenForRequest` and `middleware.ValidateTokenMiddleware` in [server/middleware/auth.go](server/middleware/auth.go)). GET requests must have `Authorization`; non-GET may supply body tokens. Use `auth.RequestHasScope` and `requireScope` helpers in handlers.
- **Content types**: Only `application/json`, `application/x-www-form-urlencoded`, or `multipart/form-data` are accepted for Micropub posts; media uploads require multipart. Validators live in [server/util/mediatype.go](server/util/mediatype.go) and multipart parsing utilities in [server/util/multipart.go](server/util/multipart.go).
- **Micropub GET handlers**: `q=config` returns media endpoint and syndication targets, `q=source` pulls stored mf2 docs (optionally filtered by `properties[]`), and `q=syndicate-to` currently returns empty (see [server/handler/get](server/handler/get)).
- **Micropub POST handlers**: [server/handler/post](server/handler/post) dispatches `create` (default), `update`, `delete`, `undelete`. Body parsing uses `ReadBody` to normalize JSON/form/multipart and strip `access_token`.
- **Document model**: Content is stored as mf2 documents (`util.Mf2Document` with `type` and `properties`). Slugs are required; `Create` derives one from `mp-slug`, generated slug, or UUID, then ensures uniqueness via `ContentStore.ExistsBySlug` (see [server/handler/post/create.go](server/handler/post/create.go)). Server commands (`mp-*`) are removed before persisting.
- **Updates/deletes**: `update` only accepts JSON; applies `replace`, `add`, and `delete` mutations (map or property list) before persisting. Slug recomputation is triggered when `name`, `content`, or `slug` properties are replaced with non-empty arrays; if the URL changes, returns HTTP 201 with Location header (Micropub spec compliant). Collision detection happens before persistence; duplicate slugs get UUID suffixes to prevent overwrites. Empty array replacements for these properties return validation errors. `delete` toggles a `deleted` property; `undelete` clears it (see [server/handler/post/update.go](server/handler/post/update.go) and [server/handler/post/delete.go](server/handler/post/delete.go)).
- **Storage strategies**: Content store is pluggable via factories in [storage/content/factory](storage/content/factory). All stores use shared helpers in [storage/content/helpers.go](storage/content/helpers.go) for slug operations (`shouldRecomputeSlug`, `computeNewSlug`, `ensureUniqueSlug`). Strategies: (1) Git: clones a repo, fast-forwards, writes `<slug>.json`, commits, and pushes; protected by a mutex with `existsBySlugUnlocked` helper to prevent deadlocks; collision checks happen before file writes (see [storage/content/git.go](storage/content/git.go)). (2) SQL: supports postgres/mysql using table `<prefix>_content`; stores JSON payloads and tracks `deleted` flag; uses transactions (BeginTx/Commit) for atomic DELETE+INSERT on slug changes (see [storage/content/sql.go](storage/content/sql.go)). (3) D1: uses Cloudflare D1 HTTP API with the same table shape; config needs `account_id`, `database_id`, `api_token`, optional `endpoint`, and `table_prefix`; uses sequential batch execution for DELETE+INSERT since D1 lacks full transactions (see [storage/content/d1.go](storage/content/d1.go)).
- **Media strategy**: Media store factory in [storage/media/factory](storage/media/factory) defaults to S3-compatible. `S3MediaStore` validates bucket existence at startup and builds public URLs based on `public_url` or endpoint/virtual-host logic (see [storage/media/s3.go](storage/media/s3.go)). Upload handler maps file field to `photo`/`video`/`audio` based on MIME or extension.
- **Configuration**: Loaded with Viper, validated via `validator` plus custom rules (`abspath`, `localpath`, `identifier`) in [config/config.go](config/config.go) and [config/validation.go](config/validation.go). Default sample config is in [config.default.yml](config.default.yml); CLI flag `-config` selects the file.
- **Logging**: Request-scoped logging is available via `util.RequestLogger`; middleware wraps verified requests with user/me info for downstream logging (see [server/util/logging.go](server/util/logging.go)).
- **Responses**: Use helpers in [server/resp/resp.go](server/resp/resp.go) to emit Micropub-compliant status codes and JSON error envelopes.
- **Running the server**: `go run ./cmd/scribble -config config.yml` (or build and run the binary). Ensure the configured content and media backends are reachable (Git auth/S3 bucket) before hitting endpoints.
- **Tests**: Run `go test ./...`; coverage helper exists at [hack/coverage.sh](hack/coverage.sh). S3 and Git interactions are covered by mocks/fakes where necessary, so tests should run offline.
- **Common pitfalls**: Provide `access_token` in only one place; keep request bodies under configured limits; ensure content slugs resolve from URLs via `SlugFromURL`; Git backend assumes `main` branch and uses `existsBySlugUnlocked` internally to avoid deadlocks (never call `ExistsBySlug` while holding the mutex); SQL backend picks placeholders based on driver (`pgx` vs `mysql`); empty array replacements for `name`, `content`, or `slug` properties will fail validation; collision detection always happens before writes to prevent overwrites.